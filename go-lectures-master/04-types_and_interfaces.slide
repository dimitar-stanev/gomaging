Типове и интерфейси
17.10.2013

fmi@golang.bg
http://fmi.golang.bg/
@fmi_golang

* Но преди това...


* Въпрос за мъфин #1

Какво са масивите в Go?
Могат ли да имат променлива дължина?
Какво е `range`?

- Структура от данни, която позволява да имаме много елементи от един и същи тип на едно място с бърз достъп по индекс.
- Не могат, винаги са с константен размер.
- Ключова дума, която позволява итерирането по индекс и стойност на масиви, хешове, etc.


* Въпрос за мъфин #2

Как са имплементирани слайсовете в Go?

- Всеки слайс сочи към масив с големина не по-малка от тази на слайса. Къде е началото, както и размерът на слайса (взет с `len`) определя този слайс каква част от масива вижда.


* Въпрос за мъфин #3

arr := [6]float64{1,2,3,4,5,6}
x := arr[1:]
slice1 := append(x, 4)
Какви типове имат `arr`, `x`, `slice1`?
Какво ще върнат `len(x)`, `cap(x)`, `len(slice1)`, `cap(slice1)`?

- [6]float64
- []float64
- []float64
- 5
- 5
- 6
- 10


* Въпрос за мъфин #4

Какво прави този код:

    var x map[string]int
    x["key"] = 10
    if name, ok := x["key"]; ok {
        fmt.Println(name, ok)
    }

- Гърми runtime. Ами ако първият ред беше x := make(map[string]int)?
- Изписва 10, true


* Въпрос за мъфин #5

Каква е разликата между `new` и `make` и кога се ползва едното, и кога другото?

- `new` само заделя памет и я нулира, за разлика от `make`, което инициализира обекта. `new` ползваме за наши типове (структури), `make` само за слайсове и хешове. `new` връща указател, `make` връща стойност.


* Собствени типове

- От всеки тип в езика можем да създаваме наши типове
- Не се различават по нищо от вградените

    type integer int
    type float float64
    type chars string

- Не особено полезно, на пръв поглед
- Но те могат и повече

* Нека разгледаме функцията Abs

    func Abs(i integer) integer {
        switch {
            case i < 0:
                return -i
            case i == 0:
                return 0
            default:
                return i
        }
    }

    var number integer = -42
    positiveInteger := Abs(number)

- Така се дефинира обикновена функция `Abs`, която се извиква като ѝ се подаде integer като аргумент
- Това не е обектно-ориентираният начин да се направи подобно нещо


* Обектно-ориентираният начин да се направи подобно нещо

    func (i integer) Abs() integer {
        switch {
            case i < 0:
                return -i
            case i == 0:
                return 0
            default:
                return i
        }
    }

    var number integer = -42
    number.Abs()


* Какво точно е метод?

- Методите се изпълняват върху конкретен тип
- Той се нарича receiver
- Методите могат да се дефинират *само* върху типове, дефинирани в същия пакет
- Методите имат достъп до private полетата в типа
- На практика, дефинират държанието на типа


* Що е то receiver-а?

- Няма фиксирана ключова дума за това. Има просто конвенция
- Той може да бъде по стойност, както и указател

*** По стойност
- Работи се върху копие на обекта
- Това може да е скъпа операция за големи обекти

*** Като указател
- Работи се върху самия обект
- Всяка промяна в метода се отразява на оригиналния обект

- Няма различен синтаксис за използването на двата вида receiver-и.


* Пример

.play code/04/integer.go /^type/,/number.Abs()/

* struct

- Същите неща могат да се правят и върху композитни типове
- Нека си дефинираме типове за триъгълник и правоъгълник

    type Rectangle struct {
        x, y int
    }

    type Triangle struct {
        x, y, z int
    }


* Методи за тези типове

    func (r *Rectangle) Circumference() int {
        return 2 * (r.x + r.y)
    }

    func (r *Triangle) Circumference() int {
        return r.x + r.y + r.z
    }

* Интерфейси

- Какво правим, ако искаме да имаме списък от геометрични фигури, на които ще търсим обиколката?
- Тези типове нямат общ "родител"
- Това в Go се постига с интерфейси
- Общият интерфейс на двете фигури е методът `Circumference()`

.image assets/interface.png

* Дефиниция на интерфейс

    type Shape interface {
        Circumference()
    }

- Това е нов абстрактен тип, от който не можем да създаваме обекти, но можем да имаме променливи от него
- Всеки тип, който има метод `Circumference` със същата сигнатура, имплементира `Shape`
- Двата типа `Triangle` и `Rectangle` имплицитно го имплементират
- Променливите от тип интерфейс са първокласни обекти в Go


* Пример

.play code/04/sum_of_areas.go /^func sumOfCircumferences/,/^}/


* Вложени типове

- Можем да накраме един тип да присвои държанието на друг тип
- Това не е наследяване в смисъла на OOP
- Влагащият тип не е от тип вложения (демек няма is-a релация)
- Просто получава всички негови полета и методи
- Има два начина да ги използваме


* Композиция

_Конструираме_един_тип,_комбинирайки_няколко_прости_други_типa._

*** Пример:
Искаме да си направим smartphone. Не откриваме топлата вода, а просто го наблъскваме с каквито джаджи се сетим.

    type Smartphone struct {
        phone BasicPhone
        camera CameraModule
        wifi WiFiModule
        screen MultiTouchScreen
        battery DamnHugeBattery
    }

Всеки един от тези типове отговаря за точно едно нещо и може да бъде използвано самостоятелно.


* Квази-Наследяване

Вярваме, че знаете как работи то. Дори сме сигурни, че сте правили хора и студенти:

    type Student struct {
        Person
        facultyNumber int16
    }

Вложеният тип, е анонимен, което присвоява всичките му методи и атрибути на базовия клас.


* Множествено наследяване

Да, имате право на много анонимни вложени типа. Не го правете.


* Stringer

    type Stringer interface {
        String() string
    }

Всеки тип, който имплементира този интерфейс, може да бъде принтиран в `Printf` например с `%s`.
`Printf` просто ще извиква `String()` и ще вземе стойността.


* Duck typing

Всеки обект имплементира празния интерфейс

    interface{}

С променлива от такъв тип не можем да правим абсолютно нищо. Това може да звучи безполезно, но не е, ако имаме следното...


* Type Assertions

    var value interface{}
    value = 20
    value = "asd"
    str := value.(string)

На последния ред или ще се паникьосаме, или в `str` ще имаме стойността на `value`, ако тя наистина е била от тип `string`.


* Interface Conversions

    var value interface{}
    switch str := value.(type) {
    case string:
        return str
    case Stringer:
        return str.String()

Начин да се държим по различен начин въз основа на типа на нещо.
