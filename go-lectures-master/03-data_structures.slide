Структури от данни
15.10.2013

fmi@golang.bg
http://fmi.golang.bg/
@fmi_golang

* Но преди това...


* Въпрос за мъфин #1

Функциите в Go могат ли да приемат по повече от един аргумент? Могат ли да връщат по повече от един аргумент? Могат ли да приемат произволен брой аргументи? Могат ли да връщат произволен брой аргументи?

- да
- да
- да
- не


* Въпрос за мъфин #2

За какво се ползва ключовата дума func в езика?

- Функции
- Ламбди
- Методи


* Въпрос за мъфин #3

За какво се ползва `_`?

- Ако нямаме нужда от дадена стойност, за да не ни изгърми при компилация, присвояваме я на `_`.


* Въпрос за мъфин #4

Какво значи closure и има ли той почва у Go?

- Closure е свойството на ламбда функции да "обгръщат" променливи извън самата функция и да могат да ги достъпват и променят. В Go има closures.


* Въпрос за мъфин #5

Кажете няколко разлики между C и Go указателите.

- Няма адресна аритметика в Go.
- Не можем да имаме указатели към константи.
- Можем да връщаме указатели към локални стойности като резултат от функция.


* Arrays

- Последователност от еднакви по тип елементи
- С конкретна дължина

.play code/03/array.go /^func main()/,/^}/

Очевидно броим от 0


* Инициализация

    var x [5]float64
    x[0] = 98
    x[1] = 93
    x[2] = 77
    x[3] = 82
    x[4] = 83

или накратко:

    x := [5]float64{98, 93, 77, 82, 83}


* Полезнотии

- `len()` - връща размера като int
- `range` - ключова дума, която позволява да итерираме по индекс и стойност

    for index, value := range arr {
        ...
    }



    for index := 0; index < len(arr); index++ {
        value := arr[index]
        ...
    }

Тези два цикъла са еквивалентни


* Slices

Като масивите имат дължина и могат да се индексират, но дължината им може да се променя.

    var x []float64

Горното само създава променливата, а се инициализира по следния начин:

    x := make([]float64, 5)

Това указва на слайса да бъде с размер 5. Всеки слайс е част от масив с не по-малка дължина от слайса.

    x := make([]float64, 5, 10)

Това е същото като горното, но този слайс сочи към масив с размер 10.


* Слайсове в действие

    arr := [6]float64{1,2,3,4,5,6}
    x := arr[1:5]

Създаваме слайс от втори до четвърти елемент включително на масива arr.

    x := arr[2:] // Взема всички без първите два елемента
    x := arr[:2] // Взема първите два елемента
    x := arr[:]  // Взема всички елементи


* Структура

    x := []int{2, 3, 5, 7, 11}
    y := x[1:3]

.image assets/slice.jpg

* Полезнотии

* append

    slice1 := []int{1,2,3}
    slice2 := append(slice1, 4, 5)

1. Създаваме `slice1` с три елемента
2. От `slice1` правим `slice2`, с още два елемента в края

    slice1 := []int{1,2,3}
    slice1 = append(slice1, 4, 5)

1. Създаваме `slice1` с три елемента
2. Добавяме два елемента в края му

* copy

    slice1 := []int{1,2,3}
    slice2 := make([]int, 2)
    copy(slice2, slice1)

1. Създаваме `slice1` с три елемента
2. Създаваме `slice2` с два елемента (нули)
3. Копираме първите два елемента от `slice1` в `slice2`

* len и cap

- `len(x)` - Взема размера на slice-а
- `cap(x)` - Взема размера на масива, към който slice-а сочи

* Maps

Неподредена колекция от двойки ключове и стойности

    var x map[string]int

Ключовете в `x` са низове, а стойностите числа

За да го инициализраме, ползваме `make`:

    x := make(map[string]int)

Ползваме го както масиви и слайсове:

    x["key"] = 10

За да вземем двойка по ключ:

    value, ok := x["key"]

`ok` е `true`, ако съществува двойка с такъв ключ. В противен случай `value` е `nil`


* Полезнотии

- delete

    x := make(map[string]int)
    delete(x, "key")

Изтрива двойката, чийто ключ е "key"

- Проверка за наличие

    if name, ok := x["key"]; ok {
        fmt.Println(name, ok)
    }


* Structs

- Добре познатите C структури
- Контейнер, който съдържа полета от други типове

    type Person struct {
        name string
        age uint
    }

    var chochko Person
    chochko.name = "Чочко"
    chochko.age = 27

Други начини за инициализиране:

    chochko := Person{name: "Чочко", age: 27}
    chochko := Person{"Чочко", 27}


* new()

- Алокира памет, която да използваме за дадения тип
- Връща указател към нулирана, но не инициализирана памет

    chochko := new(Person)
    chochko.name = "Чочко"
    chochko.age = 27

- chochko е *Person, но се използва по същия начин ('cause -> is so 80s)

* new() vs. make()

new само заделя памет, а make инициализира, т.е.:

.play code/03/new_vs_make.go

- Демек `make` се ползва само върху `slice` и `map`
