Concurrency 102
12.11.2013

fmi@golang.bg
http://fmi.golang.bg/
@fmi_golang


* Cond

- Нарича се `condition-variable` или `monitor`
- Синхронизира горутини на принципа на съобщаването за настъпване на дадено събитие
- Demo cond.go


* Communicate by sharing vs. Share by communicating


* Channels

- Вграден тип, който се използва за комуникация между две горутини.
- Може да се използва и за синхронизация
- За тях има специален синтаксис
- Ползваме нещата от `sync`, ако не можем да ползваме канали


* Употреба на канали

- Инстанцират се с `make`
- Подава се типа, който ще се пренася от канала
- Могат да бъдат буферирани и небуферирани
- В канал може да се изпраща и от него може да се получава
- Когато изпращаме или получаваме, това може да блокира


* IO в канал

Операциите по изпращане и получаване се изпълняват с оператора `<-`

- `chan`<-`стойност` изпраща по канала
- `[променлива]`<-`chan` получава от канала

Канал може да бъде затворен

- Повече не може да бъде отворен
- Никога не блокира
- Писането в него води до паника
- Четенето връща (буферираната) стойност


* Пример

    c := make(chan int)

    go func() {
        list.Sort()
        c <- 1
    }()

    doSomethingForAWhile()
    <-c


* По-сложен пример

    var sem = make(chan int, MaxOutstanding)

    func handle(r *Request) {
        <-sem
        process(r)
        sem <- 1
    }

    func init() {
        for i := 0; i < MaxOutstanding; i++ {
            sem <- 1
        }
    }

    func Serve(queue chan *Request) {
        for {
            req := <-queue
            go handle(req)
        }
    }


* Channel within a channel within a channel... chancespion!


* select

   select {
   case v1 := <-c1:
       fmt.Printf("received %v from c1\n", v1)
   case v2 := <-c2:
       fmt.Printf("received %v from c2\n", v1)
   case c3 <- c3:
       fmt.Printf("sent %v to c3\n", 23)
   default:
       fmt.Printf("no one was ready to communicate\n")
   }


Накратко: `switch` за канали.
Надълго: Изчаква първия канал, по който е изпратена стойност

- Ако по никой от каналите не е изпратено нищо, изпълнява `default`
- Ако няма `default` блокира и изчаква


* Пример

   select {
   case v1 := <-c1:
       fmt.Printf("received %v from c1\n", v1)
   case <- time.After(5 * time.Second):
       fmt.Printf("timed out\n")
   }

