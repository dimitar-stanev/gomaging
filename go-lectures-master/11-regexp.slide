Регулярни изрази
14.11.2013

fmi@golang.bg
http://fmi.golang.bg/
@fmi_golang


* История

- Разработени са като чисто теоритичен модел около 1950г.
- В езикът SNOBOL присъстват понятия като `pattern`matching` през 1962г.
- Кен Томпсън ги имплементира в QED за CTSS
- Денис Ричи ги имплементира в QED за GE-TSS
- Двамата по-късно създават UNIX и ги вкарват там
- От 1970 насам има `ed`, `sed`, `grep`, `egrep`, `awk`, and `lex`...
- В PERL се стандартизират като PCRE


* Проблемна област

най-общо: работа с текстови низове

- Търсене на по-сложна последователност от символи в низ
- Заместване на такива последователности с нещо друго
- Модифициране на текстови последователности (например, Markdown към HTML)
- Проверка дали даден низ отговаря на определени условия (валидация)


* Понятия и терминология

- „шаблон“, още „регулярен израз“ (pattern)
- Специални символи (meta characters)
- Екраниране на специалните символи (escape-ване)
- Повторители и повторение (quantifiers and repetition)
- Класове от символи (character classes)
- Групи
- Флагове (modifiers) на шаблона


* Регулярните изрази в контекста на Go

- Имплементирани са в пакета `regexp`
- Всеки регулярен израз е от типa `regexp.Regexp`
- Всеки регулярен израз се дефинира с ` около себе си
- Той има 16 метода за търсене на даден израз в стринг
- `Find(All)?(String)?(Submatch)?(Index)?`
- Използват същия синтаксис като Perl, Ruby, Python...

    godoc regexp/syntax

* Задаване на шаблон

Всеки символ, освен някои специални, означава себе си.

Цялата магия е в специалните символи:
    . \| ( ) [ ] { } + \ ^ $ * ?

Някои символи са специални само в определен контекст (например символът -)

\ пред специален символ го прави неспециален такъв.


* Компилация на регулярен израз

- Преди да можем да използваме нашия регулярен израз, той трябва да бъде компилиран
- В някои езици тази стъпка може да бъде изпусната от програмиста и се изпълнява имплицитно
- В Go това може да се направи с метода `Compile()` или `MustCompile()`

    re, err := regexp.Compile(`Hello`)
    re := regexp.MustCompile(`Hello`)

Второто изпада в паника, ако регулярният израз не е валиден

* Пример

    re, err := regexp.Compile(`Hello`)

    if err != nil {
        fmt.Printf("There is a problem with your regexp.\n")
        return
    }

    if re.MatchString("Hello Regular Expression.") == true {
        fmt.Printf("Match ")
    } else {
        fmt.Printf("No match ")
    }


* Специални символи (meta characters)

- . съвпада с един произволен символ (с изключение на символите за нов ред)
- [ и ] се ползват за дефиниране на класове от символи
- *, ?, +, { и } се ползват за указване на повторения
- ^, $, \b, \B и т.н. са "котви" и съответстват на определени "междусимволни дупки" :)
- | има смисъл на "или", например:

    re := regexp.MustCompile(`day|nice`)
    re.MatchString("A nice dance-day")


* Екраниране на специалните символи (escape-ване)

- \ пред специален символ го прави неспециален такъв (екранира го)
- За да вкарате наклонена черта, ползвате \\


* Класове от символи (character classes)

- Заградени между [ и ]
- Наподобяват множества
- Match-ват един символ от посочените вътре
- Могат да се декларират диапазони, например [a-z] или [0-9A-F]
- Ако първият символ в класа е ^, това означава "някой символ, който не е посочен в класа"
- Можете да екранирате тире в символен клас така: [a\-b]
- Друг вариант е да сложите тирето в началото или в края на класа: [-abc] или [abc-] - тук то няма специален смисъл
- Има предефинирани класове от символи

    re := regexp.MustCompile(`H\wllo`)
    fmt.Printf("%v", re.MatchString("Hello Regular Expression."))


* Предефинирани класове от символи

- \w - символ от дума ([a-zA-Z0-9_])
- \W - символ, който не може да участва в дума ([^a-zA-Z0-9_])
- \d - цифра ([0-9])
- \D - символ, който не е цифра ([^0-9])
- \s - whitespace-символ (/[ \t\r\n\f]/)
- \S - символ, който не е whitespace (/[^ \t\r\n\f]/)


* ASCII character classes:

- [:alnum:] alphanumeric ([0-9A-Za-z])
- [:alpha:] alphabetic ([A-Za-z])
- [:ascii:] ASCII ([\x00-\x7F])
- [:blank:] blank ([\t ])
- [:cntrl:] control ([\x00-\x1F\x7F])
- [:digit:] digits ([0-9])
- [:graph:] graphical ([!-~] == [A-Za-z0-9!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])
- [:lower:] lower case ([a-z])
- [:print:] printable ([ -~] == [ [:graph:]])
- [:punct:] punctuation ([!-/:-@[-`{-~])
- [:space:] whitespace ([\t\n\v\f\r ])
- [:upper:] upper case ([A-Z])
- [:word:] word characters ([0-9A-Za-z_])
- [:xdigit:] hex digit ([0-9A-Fa-f])

* Unicode character class names--scripts:

- Arabic
- Braille
- Buginese
- Canadian_Aboriginal
- Cherokee
- Cyrillic
- Gothic
- Greek
- [...]

    re := regexp.MustCompile(`\p{Cyrillic}`)
    fmt.Printf("%v", re.FindString("Bаba"))

* Котви

- Не съвпадат с реални символи, а вместо това с невидимите граници между тях
- ^ съвпада с началото на низ или ред в multiline режим
- $ съвпада с края на низ или ред в multiline режим
- \A съвпада с началото на текстов низ
- \z съвпада с края на низ
- \b отговаря на граница на дума (когато е извън [ и ]; вътре означава backspace)
- \B отговаря на място, което не е граница на дума


* Повторители (quantifiers)

- Важат за непосредствено предхождащия ги символ/клас/група; ще го означим със s
- s* означава нула или повече повторения на s
- s+ търси едно или повече повторения на s
- s? съвпада с нула или едно повторение на s
- s{m,n} означава между m и n повторения на s
- В последното можем да пропуснем m или n:
- s{,n} има смисъл на нула до n повторения, а s{m,} — поне m повторения
- s{n} означава точно n повторения


* Алчност (greedy)

- По подразбиране повторителите са "алчни", т.е. изяждат колкото се може повече от низа
- Това поведение може да се контролира с ? след повторителя
- Например .*? кара повторителя * да се държи не-лакомо
- Внимавайте с лакомите повторители


* Групи и прихващане

Символите ( и ) се използват за логическо групиране на части от шаблона с цел:

- Контролиране областта на влияние на дадена операция
- Например, следното ще match-ва низове, съдържащи думите day или dance: `\bda(y|nce)\b`
- Възможност за референция към „ограденото“ в скобите
- Задаване на по-специални (и не толкова често употребявани) конструкции


* Флагове

- i case-insensitive
- m multi-line mode: ^ и $ хващат И начало на ред и край на ред
- s Позволяват на . да хваща \n
- U ungreedy: обръщат значението на x* и x*?, x+ и x+?, ...

    regexp.Compile(`(?i)n`)

*  Regular Expression Matching Can Be Simple And Fast

(but is slow in Java, Perl, PHP, Python, Ruby, ...)
Russ Cox
rsc@swtch.com
January 2007

.link http://swtch.com/~rsc/regexp/regexp1.html

