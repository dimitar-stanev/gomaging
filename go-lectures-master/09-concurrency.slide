Concurrency 101
07.11.2013

fmi@golang.bg
http://fmi.golang.bg/
@fmi_golang

* Що е то concurrency?


* Concurrency vs. Parallelism


* Moore's law

А какво става, когато имаме много ядра?


* IO-bound vs. CPU-bound

- CPU-bound са програми, които главно зависият от време, прекарано в процесора
- IO-bound са програми, които главно зависят от време, прекарано в чакане (мрежа, памет, диск)


* Processes vs. Threads (Green & Native)

- Три начина за конкурентност
- Кой ще обясни разликите?


* Подходи

- Процеси
- Нишки (два вида)
- Актьори
- Мега умни компилатори?


* В C ползват вилици

    #include <stdio.h>

    int main()
    {
        printf("before\n");
        if (fork())
            printf("father\n");
        else
            printf("son\n");
        printf("both\n");
    }

- `fork` създава ново копие на програмата, която изпълняваме
- Всички ресурси и променливи запазват стойността си в процеса-син
- След създаването на новия процес, всички промени са локални
- Все едно клонираме хора, за да вършим повече работа едновременно


* Синхронизация на вилици

    #include <stdio.h>
    #include <unistd.h>

    int main()
    {
        pid_t pid = fork();
        if (pid == 0)
        {
            execl("/bin/sleep", "/bin/sleep", "2", (char *) 0);
        }
        else
        {
            waitpid(pid, NULL, 0);
        }
        printf("done!\n");
        return 0;
    }

- `execl` спира изпълнението на текущия процес и зарежда друг
- `waitpid` позволява на родителя да чака свършването на конкретен син


* Как работи 'ps aux | grep myprocess'?

Demo pipes.c

- `dup2` затваря подадения файлов дескриптор и дуплицира в него първия аргумент
- `close` затваря файлов дескриптов


* Предимства и недостатъци на fork

Против:

- Само за UNIX
- Създаването на нов процес е бавно и паметоемко
- Комуникацията между процеси е трудна - нямат обща памет

За:

- Стабилност
- Синът е независим - ако омаже нещо, бащата няма да пострада


* В Go се правим на модерни

- Играем го по-културно
- Чрез библиотеката `syscall` можете да вдигнете нов процес
- Не го правете, ако не знаете какво правите


* Нишки

- Много нишки живеят в един и същи процес
- Следователно имат достъп до една и съща памет
- Глобалните променливи са общи за нишките
- Създават се бързо и лесно
- Това е концепция в операционните системи
- Някои езици ги поддържат директно
- Други ги скриват зад ниво на абстрактност


* Goroutines

Go е един от тези езици.

- Зелени нишки
- Има умен scheduler, който мапва горутини към OS нишки
- Има синтаксис за тях и употребата им е тривиална и повсеместна
- Практически безплатни са за създаване от към памет и процесорно време

    go doAnotherThing()


* Пример

.play code/09/announce.go


* Проблеми, свързани с нишки

От това, че имат една и съща памет, следва, че могат да достъпват едни и същи променливи

    int i = 0

    thread1 { i++ }
    thread2 { i++ }

    wait { thread1 } { thread2 }
    print i

Тук `i` накрая може да бъде 1 или 2.


* Критични секции

- Части от кода, които могат да бъдат изпълнени само от една нишка/процес в даден момент, се наричат критични секции
- Те са критична част от многозадачното програмиране
- Има много похвати за реализирането на критични секции.
- STM, Semaphors & Co., Message passing, Actors

В Go имаме Semaphors и Message passing


* sync

Пакет, който ни дава синхронизационни примитиви от ниско ниво:

- `Cond`
- `Mutex`
- `Once`
- `RWMutex`
- `WaitGroup`


* WaitGroup

Изчаква колекция от горутини да приключат и чак тогава продължава с изпълнението.
Така не правим простотии със `time.Sleep`, както одеве.

    package sync

    type WaitGroup struct {}

    func (*WaitGroup) Add()
    func (*WaitGroup) Done()
    func (*WaitGroup) Wait()

* Пример

.play code/09/waitgroup.go /^func main/,/^}/


* Mutex

    package sync

    type Mutex struct {}

    func (*Mutex) Lock()
    func (*Mutex) Unlock()

- Дава достъп до даден ресурс само на една горутина по едно и също време
- Ако втора се опита да го достъпи, тя чака, докато ресурсът не бъде освободен
- Ако много горутини чакат за един ресурс, достъп се дава на една от тях на случаен принцип
- Има смисъл да се ползва като `private` атрибут на наш тип
- `Unlock()` е добра идея да бъде в `defer`
- Имплементира интерфейса `sync.Locker`


* Once

Обект от този тип ще изпълни точно една функция.

.play code/09/once.go /^func main/,/^}/

